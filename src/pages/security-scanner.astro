---
// Legacy basic security scanner route. Permanently redirect to enhanced scanner.
import { redirect } from 'astro:redirect';
export async function GET() {
  return redirect('/enhanced-security-scanner', 301);
}
export async function POST() {
  return redirect('/enhanced-security-scanner', 301);
}
// Fallback HTML for clients without redirect handling (rare)
const html = `<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="refresh" content="0; url=/enhanced-security-scanner" /><link rel="canonical" href="/enhanced-security-scanner" /><title>Redirecting...</title></head><body><p>Redirecting to <a href="/enhanced-security-scanner">Enhanced Security Scanner</a>...</p></body></html>`;
---
{html}
    </div>
  </div>
</BaseLayout>

<style>
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  .scanning {
    animation: pulse 2s infinite;
  }
</style>

<script>
  class SecurityScanner {
    constructor() {
      this.scanForm = document.getElementById('security-scan-form');
      this.progressSection = document.getElementById('scan-progress');
      this.resultsSection = document.getElementById('scan-results');
      this.welcomeMessage = document.getElementById('welcome-message');
      this.progressBar = document.getElementById('progress-bar');
      this.currentTask = document.getElementById('current-task');
      this.overallProgress = document.getElementById('overall-progress');
      this.resultsContainer = document.getElementById('results-container');
      this.securityScore = document.getElementById('security-score');
      this.techModeToggle = document.getElementById('tech-mode-toggle');
      
      this.scanResults = {};
      this.totalTasks = 0;
      this.completedTasks = 0;
      this.engineerMode = false;
      
      this.init();
    }
    
    init() {
      this.scanForm.addEventListener('submit', (e) => {
        e.preventDefault();
        this.startScan();
      });
      
      document.getElementById('new-scan-btn')?.addEventListener('click', () => {
        this.resetScan();
      });
      
      document.getElementById('export-pdf-btn')?.addEventListener('click', () => {
        this.exportPDF();
      });
      
      document.getElementById('export-json-btn')?.addEventListener('click', () => {
        this.exportJSON();
      });
      
      document.getElementById('export-csv-btn')?.addEventListener('click', () => {
        this.exportCSV();
      });
      
      // Tech mode toggle
      this.techModeToggle.addEventListener('change', () => {
        this.toggleTechMode();
      });
    }
    
    toggleTechMode() {
      this.engineerMode = this.techModeToggle.checked;
      
      // Toggle UI elements
      const engineerOptions = document.getElementById('engineer-options');
      const businessDesc = document.getElementById('business-desc');
      const engineerDesc = document.getElementById('engineer-desc');
      const businessFeatures = document.getElementById('business-features');
      const engineerFeatures = document.getElementById('engineer-features');
      const businessCapabilities = document.getElementById('business-capabilities');
      const engineerCapabilities = document.getElementById('engineer-capabilities');
      const exportJsonBtn = document.getElementById('export-json-btn');
      const exportCsvBtn = document.getElementById('export-csv-btn');
      const cvssScore = document.getElementById('cvss-score');
      const cvssLabel = document.getElementById('cvss-label');
      
      if (this.engineerMode) {
        engineerOptions.classList.remove('hidden');
        businessDesc.classList.add('hidden');
        engineerDesc.classList.remove('hidden');
        businessFeatures.classList.add('hidden');
        engineerFeatures.classList.remove('hidden');
        businessCapabilities.classList.add('hidden');
        engineerCapabilities.classList.remove('hidden');
        exportJsonBtn.classList.remove('hidden');
        exportCsvBtn.classList.remove('hidden');
        cvssScore.classList.remove('hidden');
        cvssLabel.classList.remove('hidden');
      } else {
        engineerOptions.classList.add('hidden');
        businessDesc.classList.remove('hidden');
        engineerDesc.classList.add('hidden');
        businessFeatures.classList.remove('hidden');
        engineerFeatures.classList.add('hidden');
        businessCapabilities.classList.remove('hidden');
        engineerCapabilities.classList.add('hidden');
        exportJsonBtn.classList.add('hidden');
        exportCsvBtn.classList.add('hidden');
        cvssScore.classList.add('hidden');
        cvssLabel.classList.add('hidden');
      }
    }
    
    async startScan() {
      const targetUrl = document.getElementById('target-url').value;
      const legalAgreement = document.getElementById('legal-agreement').checked;
      
      if (!legalAgreement) {
        alert('Please confirm you have authorization to scan this website.');
        return;
      }
      
      // Show progress, hide welcome
      this.welcomeMessage.classList.add('hidden');
      this.progressSection.classList.remove('hidden');
      
      // Configure scan based on checkboxes
      const scanConfig = {
        headers: document.getElementById('scan-headers').checked,
        ssl: document.getElementById('scan-ssl').checked,
        info: document.getElementById('scan-info').checked,
        common: document.getElementById('scan-common').checked,
        // Engineer mode options
        advancedHeaders: this.engineerMode && document.getElementById('scan-advanced-headers').checked,
        waf: this.engineerMode && document.getElementById('scan-waf').checked,
        subdomain: this.engineerMode && document.getElementById('scan-subdomain').checked,
        techStack: this.engineerMode && document.getElementById('scan-tech-stack').checked,
        cve: this.engineerMode && document.getElementById('scan-cve').checked
      };
      
      this.totalTasks = Object.values(scanConfig).filter(Boolean).length;
      this.completedTasks = 0;
      
      try {
        await this.performScan(targetUrl, scanConfig);
        this.displayResults();
      } catch (error) {
        console.error('Scan error:', error);
        this.showError('Scan failed: ' + error.message);
      }
    }
    
    async performScan(targetUrl, config) {
      this.scanResults = { url: targetUrl, findings: [], score: 0 };
      
      if (config.headers) {
        await this.scanSecurityHeaders(targetUrl);
      }
      
      if (config.ssl) {
        await this.scanSSL(targetUrl);
      }
      
      if (config.info) {
        await this.scanInformationDisclosure(targetUrl);
      }
      
      if (config.common) {
        await this.scanCommonFiles(targetUrl);
      }
      
      // Engineer mode scans
      if (config.advancedHeaders) {
        await this.scanAdvancedHeaders(targetUrl);
      }
      
      if (config.waf) {
        await this.scanWAF(targetUrl);
      }
      
      if (config.subdomain) {
        await this.scanSubdomains(targetUrl);
      }
      
      if (config.techStack) {
        await this.scanTechStack(targetUrl);
      }
      
      if (config.cve) {
        await this.scanCVE(targetUrl);
      }
      
      this.calculateSecurityScore();
    }
    
    async scanSecurityHeaders(url) {
      this.updateProgress('Analyzing security headers...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'headers', engineerMode: this.engineerMode })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('error', 'Security Headers', 'Failed to analyze security headers', 'Check network connectivity');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanSSL(url) {
      this.updateProgress('Checking SSL/TLS configuration...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'ssl', engineerMode: this.engineerMode })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('warning', 'SSL/TLS', 'Could not verify SSL configuration', 'Manual verification recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanInformationDisclosure(url) {
      this.updateProgress('Checking for information disclosure...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'info', engineerMode: this.engineerMode })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'Information Disclosure', 'Scan incomplete', 'Manual review recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanCommonFiles(url) {
      this.updateProgress('Checking for common vulnerable files...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'common', engineerMode: this.engineerMode })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'Common Files', 'Directory scan incomplete', 'Manual enumeration recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    addFinding(severity, category, title, description, recommendation = '') {
      this.scanResults.findings.push({
        severity,
        category,
        title,
        description,
        recommendation,
        cvss: this.engineerMode ? this.calculateCVSS(severity) : null,
        exploitability: this.engineerMode ? this.getExploitability(severity) : null,
        references: this.engineerMode ? this.getReferences(category, title) : null
      });
    }
    
    calculateCVSS(severity) {
      // Simplified CVSS scoring for demo
      const cvssMap = {
        'critical': { score: 9.5, vector: 'AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H' },
        'high': { score: 8.2, vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N' },
        'medium': { score: 6.1, vector: 'AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N' },
        'low': { score: 3.7, vector: 'AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N' },
        'warning': { score: 2.3, vector: 'AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N' },
        'info': { score: 0.0, vector: 'AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N' }
      };
      return cvssMap[severity] || cvssMap['info'];
    }
    
    getExploitability(severity) {
      const exploitMap = {
        'critical': 'High - Remote code execution possible',
        'high': 'Medium - Data exfiltration likely',
        'medium': 'Low - Requires user interaction',
        'low': 'Very Low - Information disclosure only',
        'warning': 'Minimal - Configuration issue',
        'info': 'None - Informational only'
      };
      return exploitMap[severity] || 'Unknown';
    }
    
    getReferences(category, title) {
      // Mock references for engineer mode
      const refs = [];
      if (category.includes('Security Headers')) {
        refs.push('OWASP Secure Headers Project');
        refs.push('Mozilla Web Security Guidelines');
      }
      if (category.includes('SSL')) {
        refs.push('RFC 8446 - TLS 1.3');
        refs.push('NIST SP 800-52');
      }
      return refs;
    }
    
    // Engineer mode scan methods
    async scanAdvancedHeaders(url) {
      this.updateProgress('Performing advanced header analysis...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'advanced-headers', engineerMode: true })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('error', 'Advanced Headers', 'Advanced header analysis failed', 'Manual inspection recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanWAF(url) {
      this.updateProgress('Detecting Web Application Firewall...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'waf', engineerMode: true })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'WAF Detection', 'WAF detection incomplete', 'Manual payload testing recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanSubdomains(url) {
      this.updateProgress('Enumerating subdomains...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'subdomain', engineerMode: true })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'Subdomain Enumeration', 'Subdomain scan incomplete', 'Use dedicated tools like amass or subfinder');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanTechStack(url) {
      this.updateProgress('Fingerprinting technology stack...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'tech-stack', engineerMode: true })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'Technology Stack', 'Fingerprinting incomplete', 'Manual analysis with tools like Wappalyzer recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    async scanCVE(url) {
      this.updateProgress('Cross-referencing CVE database...');
      
      try {
        const response = await fetch('/api/security-scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, type: 'cve', engineerMode: true })
        });
        
        const result = await response.json();
        this.scanResults.findings.push(...result.findings);
        this.completedTasks++;
        this.updateProgressBar();
      } catch (error) {
        this.addFinding('info', 'CVE Analysis', 'CVE cross-reference incomplete', 'Manual CVE database lookup recommended');
        this.completedTasks++;
        this.updateProgressBar();
      }
    }
    
    updateProgress(task) {
      this.currentTask.textContent = task;
    }
    
    updateProgressBar() {
      const progress = (this.completedTasks / this.totalTasks) * 100;
      this.progressBar.style.width = progress + '%';
      this.overallProgress.textContent = Math.round(progress) + '%';
    }
    
    calculateSecurityScore() {
      let score = 100;
      let totalCvss = 0;
      let cvssCount = 0;
      
      this.scanResults.findings.forEach(finding => {
        switch (finding.severity) {
          case 'critical': score -= 25; break;
          case 'high': score -= 15; break;
          case 'medium': score -= 10; break;
          case 'low': score -= 5; break;
          case 'warning': score -= 3; break;
        }
        
        // Calculate average CVSS for engineer mode
        if (this.engineerMode && finding.cvss) {
          totalCvss += finding.cvss.score;
          cvssCount++;
        }
      });
      
      this.scanResults.score = Math.max(0, score);
      this.scanResults.avgCvss = cvssCount > 0 ? (totalCvss / cvssCount).toFixed(1) : 0;
    }
    
    displayResults() {
      this.progressSection.classList.add('hidden');
      this.resultsSection.classList.remove('hidden');
      
      // Update security score
      const score = this.scanResults.score;
      const cvssScore = this.scanResults.avgCvss || 0;
      
      this.securityScore.innerHTML = `
        <div class="text-2xl font-bold ${score >= 80 ? 'text-green-400' : score >= 60 ? 'text-yellow-400' : 'text-red-400'}">${score}/100</div>
        <div class="text-sm text-slate-400">Security Score</div>
      `;
      
      if (this.engineerMode && cvssScore > 0) {
        document.getElementById('cvss-score').innerHTML = `CVSS: ${cvssScore}`;
      }
      
      // Group findings by category
      const categories = {};
      this.scanResults.findings.forEach(finding => {
        if (!categories[finding.category]) {
          categories[finding.category] = [];
        }
        categories[finding.category].push(finding);
      });
      
      // Display findings by category
      this.resultsContainer.innerHTML = '';
      Object.entries(categories).forEach(([category, findings]) => {
        this.renderCategory(category, findings);
      });
      
      // If no findings, show success message
      if (this.scanResults.findings.length === 0) {
        this.resultsContainer.innerHTML = `
          <div class="text-center py-8">
            <div class="text-6xl mb-4">âœ…</div>
            <h3 class="text-xl font-bold text-green-400 mb-2">No Issues Found</h3>
            <p class="text-slate-300">The security scan completed successfully with no major issues detected.</p>
          </div>
        `;
      }
    }
    
    renderCategory(category, findings) {
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'bg-slate-700/30 rounded-lg p-4';
      
      const severityColors = {
        critical: 'text-red-400',
        high: 'text-orange-400',
        medium: 'text-yellow-400',
        low: 'text-blue-400',
        warning: 'text-purple-400',
        info: 'text-slate-400'
      };
      
      categoryDiv.innerHTML = `
        <h4 class="font-bold text-white mb-3">${category} (${findings.length} findings)</h4>
        <div class="space-y-3">
          ${findings.map(finding => `
            <div class="border-l-4 border-${finding.severity === 'critical' ? 'red' : finding.severity === 'high' ? 'orange' : finding.severity === 'medium' ? 'yellow' : 'blue'}-500 pl-4">
              <div class="flex items-start justify-between">
                <div class="flex-1">
                  <h5 class="font-medium ${severityColors[finding.severity] || 'text-slate-300'}">${finding.title}</h5>
                  <p class="text-sm text-slate-400 mt-1">${finding.description}</p>
                  ${finding.recommendation ? `<p class="text-sm text-slate-300 mt-2"><strong>Recommendation:</strong> ${finding.recommendation}</p>` : ''}
                  ${this.engineerMode && finding.cvss ? `
                    <div class="mt-3 p-2 bg-slate-800 rounded text-xs">
                      <p><strong>CVSS:</strong> ${finding.cvss.score} (${finding.cvss.vector})</p>
                      <p><strong>Exploitability:</strong> ${finding.exploitability}</p>
                      ${finding.references ? `<p><strong>References:</strong> ${finding.references.join(', ')}</p>` : ''}
                    </div>
                  ` : ''}
                </div>
                <span class="text-xs px-2 py-1 rounded ${finding.severity === 'critical' ? 'bg-red-900 text-red-300' : finding.severity === 'high' ? 'bg-orange-900 text-orange-300' : finding.severity === 'medium' ? 'bg-yellow-900 text-yellow-300' : 'bg-blue-900 text-blue-300'}">${finding.severity.toUpperCase()}</span>
              </div>
            </div>
          `).join('')}
        </div>
      `;
      
      this.resultsContainer.appendChild(categoryDiv);
    }
    
    resetScan() {
      this.resultsSection.classList.add('hidden');
      this.progressSection.classList.add('hidden');
      this.welcomeMessage.classList.remove('hidden');
      this.scanForm.reset();
      document.getElementById('scan-headers').checked = true;
      document.getElementById('scan-ssl').checked = true;
      document.getElementById('scan-info').checked = true;
      document.getElementById('scan-common').checked = true;
    }
    
    exportJSON() {
      const jsonData = {
        scan: {
          timestamp: new Date().toISOString(),
          target: this.scanResults.url,
          mode: this.engineerMode ? 'engineer' : 'business',
          score: this.scanResults.score,
          avgCvss: this.scanResults.avgCvss || null
        },
        findings: this.scanResults.findings.map(finding => ({
          ...finding,
          timestamp: new Date().toISOString()
        }))
      };
      
      const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `security-scan-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    exportCSV() {
      const headers = ['Timestamp', 'Category', 'Severity', 'Title', 'Description', 'Recommendation'];
      if (this.engineerMode) {
        headers.push('CVSS_Score', 'CVSS_Vector', 'Exploitability');
      }
      
      const rows = [headers.join(',')];
      
      this.scanResults.findings.forEach(finding => {
        const row = [
          new Date().toISOString(),
          `"${finding.category}"`,
          finding.severity,
          `"${finding.title}"`,
          `"${finding.description}"`,
          `"${finding.recommendation || ''}"`
        ];
        
        if (this.engineerMode) {
          row.push(
            finding.cvss ? finding.cvss.score : '',
            finding.cvss ? `"${finding.cvss.vector}"` : '',
            `"${finding.exploitability || ''}"`
          );
        }
        
        rows.push(row.join(','));
      });
      
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `security-scan-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    showError(message) {
      this.currentTask.textContent = 'Error: ' + message;
      this.currentTask.className = 'text-sm text-red-400';
    }
    
    exportPDF() {
      // Simple PDF export using browser print
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>Security Scan Report - ${this.scanResults.url}</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; }
              .header { border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
              .finding { margin-bottom: 15px; padding: 10px; border-left: 4px solid #333; }
              .critical { border-color: #dc2626; }
              .high { border-color: #ea580c; }
              .medium { border-color: #ca8a04; }
              .low { border-color: #2563eb; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>Security Scan Report</h1>
              <p><strong>Target:</strong> ${this.scanResults.url}</p>
              <p><strong>Security Score:</strong> ${this.scanResults.score}/100</p>
              <p><strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
            </div>
            ${this.scanResults.findings.map(finding => `
              <div class="finding ${finding.severity}">
                <h3>${finding.title} (${finding.severity.toUpperCase()})</h3>
                <p><strong>Category:</strong> ${finding.category}</p>
                <p><strong>Description:</strong> ${finding.description}</p>
                ${finding.recommendation ? `<p><strong>Recommendation:</strong> ${finding.recommendation}</p>` : ''}
              </div>
            `).join('')}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();
    }
  }
  
  // Initialize the scanner when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    new SecurityScanner();
  });
</script>
